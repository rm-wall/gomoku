<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
  <meta http-equiv="Pragma" content="no-cache" />
  <meta http-equiv="Expires" content="0" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Gomoku (Save/Load as Plain Text)</title>
  <link rel="icon" type="image/svg+xml" href="./icon.svg" />
  <link rel="apple-touch-icon" href="./icon.svg" />
  <link rel="manifest" href="./manifest.json" />
  <meta name="theme-color" content="#f4e4c1" />
  <style>
    :root { --size: 15; --cell: 36px; }
    body { margin: 0; padding: 16px; box-sizing: border-box; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; background: #f5f5f5; color: #222; }
    header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px; }
    h1 { font-size: 20px; margin: 0; font-weight: 600; }
    .app { display: grid; gap: 16px; grid-template-columns: 1fr; max-width: 1280px; margin: 0 auto; }
    @media (min-width: 960px) { .app { grid-template-columns: max-content 1fr; align-items: start; } }
    @media (min-width: 1280px) { .app { grid-template-columns: max-content 1fr 1fr; } }
    .toolbar { display: flex; flex-wrap: wrap; gap: 8px; align-items: center; background: #fff; padding: 10px; border-radius: 8px; border: 1px solid #ccc; }
    input[type="number"], input[type="file"], button, select { font: inherit; padding: 6px 8px; border-radius: 6px; border: 1px solid #aaa; background: #fff; color: #222; }
    button { cursor: pointer; touch-action: manipulation; }
    button:disabled { background-color: #f0f0f0; color: #aaa; cursor: not-allowed; }
    .boardWrap { background: #fff; padding: 32px 32px 50px 32px; border-radius: 8px; border: 1px solid #ccc; }
    .board { position: relative; width: calc(var(--size) * var(--cell)); height: calc(var(--size) * var(--cell)); background: #fdfdfd; }
    .line { position: absolute; background: #888; }
    .line.h { height: 1px; }
    .line.v { width: 1px; }
    .line.border { background: #000; }
    .line.border.h { height: 2px; }
    .line.border.v { width: 2px; }
    .stone { position: absolute; width: 24px; height: 24px; border-radius: 50%; transform: translate(-50%, -50%); display:flex; align-items:center; justify-content:center; font-size:12px; font-weight:bold; color:#fff; }
    .stone.O { color:#000; background: #fff; border: 1px solid #000; }
    .stone.X { background: #000; }
    @keyframes pulse {
      0% {
        box-shadow: 0 0 0 2px rgba(255, 0, 0, 0.7);
      }
      100% {
        box-shadow: 0 0 0 6px rgba(255, 0, 0, 0);
      }
    }
    .stone.last-move {
      animation: pulse 1.2s infinite;
    }
    .coordLabel { position: absolute; font-size: 12px; color: #000; user-select: none; pointer-events: none; }
    .side-panels { display: grid; gap: 12px; }
    .side { display: grid; gap: 12px; }
    .panel { background: #fff; border: 1px solid #ccc; border-radius: 8px; padding: 12px; }
    .panel h2 { font-size: 16px; margin: 0 0 8px; }
    .txt { width: calc(100% - 2px); min-height: 320px; resize: vertical; font: 14px/1.2 monospace; background: #fff; border: 1px solid #ccc; border-radius: 6px; padding: 8px; white-space: pre; box-sizing: border-box; }
    .row { display: flex; gap: 8px; flex-wrap: wrap; }
    .badge { display: inline-flex; align-items: center; gap: 6px; padding: 4px 12px; border: 2px solid #555; border-radius: 20px; font-size: 16px; font-weight: bold; background: #ffe680; }
    .turnStone { width: 20px; height: 20px; border-radius: 50%; border: 1px solid #000; }
    .turnStone.black { background: #000; }
    .turnStone.white { background: #fff; }

    .center-dot {
      position: absolute;
      width: 8px;
      height: 8px;
      background: #888;
      border-radius: 50%;
      transform: translate(-50%, -50%);
    }

    /* Winner Popup */
    .overlay { position: fixed; top:0; left:0; right:0; bottom:0; background: rgba(0,0,0,0.5); display:none; justify-content:center; align-items:center; z-index:1000; }
    .overlayContent { background:#fff; padding:30px 40px; border-radius:12px; text-align:center; box-shadow:0 4px 20px rgba(0,0,0,0.3); }
    .overlayContent h2 { margin:0 0 16px; font-size:22px; }
    .overlayContent button { padding:8px 16px; margin-top:12px; }

    /* Game History List */
    .gameHistoryList { display: flex; flex-direction: column; gap: 8px; max-height: 280px; overflow-y: auto; padding-right: 5px; margin-bottom: 12px; }
    .historyItem { background: #fff; border: 1px solid #ccc; border-radius: 6px; padding: 8px 12px; cursor: pointer; transition: background-color 0.2s, border-color 0.2s; display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 8px; }
    .historyItem:hover { background-color: #f0f0f0; border-color: #aaa; }
    .historyItem .deleteBtn {
      padding: 2px 6px;
      font-size: 12px;
      background-color: #e53935; /* Red */
      color: white;
      border: none;
      border-radius: 12px;
      cursor: pointer;
      margin-left: auto; /* Pushes the button to the right */
    }
    .historyItem .deleteBtn:hover {
      background-color: #c62828; /* Darker Red */
    }
    .historyItem strong { font-size: 14px; }
    .historyItem span { font-size: 12px; color: #555; }
  </style>
</head>
<body>
  <header>
    <h1 id="title">Gomoku (Save/Load as Plain Text)</h1>
    <div style="display: flex; align-items: center; gap: 16px;">
      <div id="lastModified" style="font-size: 12px; color: #555; text-align: right;"></div>
      <div class="langSelectBox">
        <select id="langSelect">
          <option value="EN" selected>English</option>
          <option value="JP">日本語</option>
          <option value="CN">中文</option>
        </select>
      </div>
    </div>
  </header>

  <div class="app">
    <div class="main-content">
      <div class="left">
        <div class="toolbar" id="mainControls">
          <label id="sizeLabel">Board size:<input id="sizeInput" type="number" min="5" max="40" step="1" value="15"></label>
          <button id="newBoardBtn">New Board</button>
          <span class="badge" id="turnBadge"><span class="turnStone black"></span> Turn: Black</span>
          <button id="undoBtn">Undo</button>
          <button id="saveGameBtn" style="display:none;">Save Game</button>
        </div>
        <div class="toolbar" id="replayControls" style="display:none;">
          <button id="replayStartBtn">|&lt;</button>
          <button id="replayPrevBtn">&lt;</button>
          <button id="replayNextBtn">&gt;</button>
          <button id="replayEndBtn">&gt;|</button>
          <button id="replayExitBtn">Exit Replay</button>
        </div>
        <div class="boardWrap">
          <div id="board" class="board"></div>
        </div>
      </div>
    </div>

    <div class="side-panels">
      <div class="panel">
        <h2 id="textPanelTitle">Plain Text</h2>
        <textarea id="txt" class="txt" spellcheck="false"></textarea>
        <div class="row">
          <button id="syncFromBoardBtn">Board → Text</button>
          <button id="syncToBoardBtn">Text → Board</button>
          <button id="copyBtn">Copy Text</button>
        </div>
      </div>
      <div class="panel">
        <h2 id="filePanelTitle">Save / Load File</h2>
        <div class="row">
          <button id="downloadBtn">Download .txt</button>
          <input id="fileInput" type="file" accept=".txt" />
          <button id="loadFileBtn" disabled>Load File</button>
        </div>
      </div>
      <div class="panel">
        <h2 id="kifuPanelTitle">Kifu Library</h2>
        <div class="row">
          <select id="kifuSelect"></select>
          <button id="loadKifuBtn">Load Kifu</button>
        </div>
      </div>
    </div>

    <div class="side">
      <div class="panel">
        <h2 id="historyPanelTitle">Game History (localStorage)</h2>
        <div id="gameHistoryList" class="gameHistoryList"></div>
        <div class="row">
          <button id="clearHistoryBtn">Clear History</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Winner Popup -->
  <div class="overlay" id="winnerOverlay">
    <div class="overlayContent">
      <h2 id="winnerText">Winner!</h2>
      <button id="closeOverlayBtn">OK</button>
    </div>
  </div>

<script>
// ======= Global State =======
let size=15;           // Board size (rows and columns)
let board=[];          // Board state: '.' empty, 'X' black, 'O' white
let turn='X';          // Current turn: 'X' or 'O'
const history=[];      // Move history [{r,c,who}]
let gameOver = false;
// --- Replay State ---
let isReplaying = false;
let replayHistory = [];
let replayStep = -1;
let replayInitialBoard = [];

// DOM References
const boardEl=document.getElementById('board');
const txt=document.getElementById('txt');
const sizeInput=document.getElementById('sizeInput');
const newBoardBtn=document.getElementById('newBoardBtn');
const undoBtn=document.getElementById('undoBtn');
const turnBadge=document.getElementById('turnBadge');
const langSelect=document.getElementById('langSelect');
const overlay=document.getElementById('winnerOverlay');
const overlayText=document.getElementById('winnerText');
const closeOverlayBtn=document.getElementById('closeOverlayBtn');
const gameHistoryListEl = document.getElementById('gameHistoryList');
const clearHistoryBtn = document.getElementById('clearHistoryBtn');
const saveGameBtn = document.getElementById('saveGameBtn');
const replayControlsEl = document.getElementById('replayControls');

// i18n Strings
const i18n={
  CN:{title:"五子棋（纯文本保存 / 载入）",size:"棋盘大小：",newBoard:"新建棋盘",undo:"悔棋",textPanel:"纯文本表示",filePanel:"保存 / 载入文件",syncFrom:"棋盘 → 文本",syncTo:"文本 → 棋盘",copy:"复制文本",download:"下载为 .txt",load:"载入所选文件",turnX:"轮到：黑",turnO:"轮到：白",winX:"黑方获胜!",winO:"白方获胜!",ok:"确定", saveGame:"保存对局", historyPanel:"对局历史 (localStorage)", clearHistory:"清空所有历史", replayExit:"退出回放", noHistory:"暂无历史对局", clearHistoryConfirm:"确定要清空所有对局历史吗？", moves:"手", wins:"胜", inProgress:"进行中", delete:"删除", deleteConfirm:"确定要删除这个对局吗？", blackWins:"黑方胜", whiteWins:"白方胜", kifuPanel:"棋谱库", loadKifu:"载入棋谱", lastModified:"最后修改时间："},
  EN:{title:"Gomoku (Save/Load as Plain Text)",size:"Board size:",newBoard:"New Board",undo:"Undo",textPanel:"Plain Text",filePanel:"Save / Load File",syncFrom:"Board → Text",syncTo:"Text → Board",copy:"Copy Text",download:"Download .txt",load:"Load File",turnX:"Turn: Black",turnO:"Turn: White",winX:"Black wins!",winO:"White wins!",ok:"OK", saveGame:"Save Game", historyPanel:"Game History (localStorage)", clearHistory:"Clear All History", replayExit:"Exit Replay", noHistory:"No game history", clearHistoryConfirm:"Are you sure you want to clear all game history?", moves:" moves", wins:" wins", inProgress:"In Progress", delete:"Delete", deleteConfirm:"Are you sure you want to delete this game?", blackWins:"Black Wins", whiteWins:"White Wins", kifuPanel:"Kifu Library", loadKifu:"Load Kifu", lastModified:"Last Modified: "},
  JP:{title:"五目並べ（テキスト保存/読み込み）",size:"盤のサイズ：",newBoard:"新しい盤",undo:"一手戻す",textPanel:"テキスト表示",filePanel:"保存 / 読み込み",syncFrom:"盤 → テキスト",syncTo:"テキスト → 盤",copy:"テキストをコピー",download:".txtをダウンロード",load:"ファイルを読み込み",turnX:"次：黒",turnO:"次：白",winX:"黒 勝ち!",winO:"白 勝ち!",ok:"OK", saveGame:"対局を保存", historyPanel:"対局履歴 (localStorage)", clearHistory:"全履歴を消去", replayExit:"再生終了", noHistory:"対局履歴がありません", clearHistoryConfirm:"本当に対局履歴をすべて消去しますか？", moves:"手", wins:"勝ち", inProgress:"進行中", delete:"削除", deleteConfirm:"この対局を削除してもよろしいですか？", blackWins:"黒勝ち", whiteWins:"白勝ち", kifuPanel:"棋譜ライブラリ", loadKifu:"棋譜を読み込み", lastModified:"最終更新日時："}
};

// ======= Language & UI =======
function updateLastModified(lang) {
  const lastModifiedEl = document.getElementById('lastModified');
  if (document.lastModified && lastModifiedEl) {
    const lastModifiedDate = new Date(document.lastModified);
    const options = { year: 'numeric', month: '2-digit', day: '2-digit', hour: '2-digit', minute: '2-digit', second: '2-digit', hour12: false };
    // Use 'undefined' to let toLocaleString use the browser's default locale
    const formattedDate = lastModifiedDate.toLocaleString(undefined, options);
    lastModifiedEl.textContent = `${i18n[lang].lastModified}${formattedDate}`;
  }
}

function setLanguage(lang){
  const L=i18n[lang];
  document.title = L.title; // Update page title
  document.getElementById('title').textContent=L.title;
  document.getElementById('sizeLabel').firstChild.textContent=L.size;
  newBoardBtn.textContent=L.newBoard;
  undoBtn.textContent=L.undo;
  document.getElementById('textPanelTitle').textContent=L.textPanel;
  document.getElementById('filePanelTitle').textContent=L.filePanel;
  document.getElementById('syncFromBoardBtn').textContent=L.syncFrom;
  document.getElementById('syncToBoardBtn').textContent=L.syncTo;
  document.getElementById('copyBtn').textContent=L.copy;
  document.getElementById('downloadBtn').textContent=L.download;
  document.getElementById('loadFileBtn').textContent=L.load;
  closeOverlayBtn.textContent=L.ok;
  saveGameBtn.textContent = L.saveGame;
  document.getElementById('historyPanelTitle').textContent = L.historyPanel;
  clearHistoryBtn.textContent = L.clearHistory;
  document.getElementById('replayExitBtn').textContent = L.replayExit;
  document.getElementById('kifuPanelTitle').textContent = L.kifuPanel;
  document.getElementById('loadKifuBtn').textContent = L.loadKifu;
  updateTurn();
  renderGameHistory();
  updateLastModified(lang); // Update last modified time with correct language
  localStorage.setItem('gomokuLang', lang); // Save language preference
  langSelect.value = lang; // Ensure dropdown is in sync
}

// ======= Board Core =======
function initBoard(n){
  if (isReplaying) exitReplay(); // If creating a new board during replay, exit replay first
  size=n;
  // Update CSS variables to ensure container dimensions change with size
  document.documentElement.style.setProperty('--size', String(n));
  // Clear and initialize
  board=Array.from({length:n},()=>Array.from({length:n},()=>'.'));
  history.length=0;
  turn='X';
  gameOver = false;
  hideWinner();
  renderBoard();
  updateTurn();
  syncTextFromBoard();
  saveGameBtn.style.display = 'none';
}

function updateTurn(){
  if (isReplaying) {
    const total = replayHistory.length;
    const stepInfo = (replayStep >= 0 && replayStep < total) ? `(${replayStep + 1}/${total})` : `(0/${total})`;
    turnBadge.textContent = `Replaying ${stepInfo}`;
    return;
  }
  const L=i18n[langSelect.value];
  const stone=document.createElement('span');
  stone.className='turnStone '+(turn==='X'?'black':'white');
  turnBadge.innerHTML='';
  turnBadge.appendChild(stone);
  turnBadge.appendChild(document.createTextNode(' '+(turn==='X'?L.turnX:L.turnO)));
}

function renderBoard(renderData = { board, history }){
  boardEl.innerHTML='';
  const CELL=parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--cell'));
  const HALF=CELL/2;
  const INNER=(size-1)*CELL;
  const lastMove = renderData.history.length > 0 ? renderData.history[renderData.history.length - 1] : null;

  // Thin lines (excluding borders)
  for(let i=1;i<size-1;i++){
    const y=i*CELL+HALF;
    const x=i*CELL+HALF;
    const hLine=document.createElement('div');
    hLine.className='line h';
    hLine.style.width=INNER+'px';
    hLine.style.transform = `translate(${HALF}px, ${y}px)`;
    boardEl.appendChild(hLine);

    const vLine=document.createElement('div');
    vLine.className='line v';
    vLine.style.height=INNER+'px';
    vLine.style.transform = `translate(${x}px, ${HALF}px)`;
    boardEl.appendChild(vLine);
  }

  // Borders
  const topBorder=document.createElement('div');
  topBorder.className='line border h';
  topBorder.style.width=(INNER + 2)+'px';
  topBorder.style.transform = `translate(${HALF - 1}px, ${HALF - 1}px)`;
  boardEl.appendChild(topBorder);

  const bottomBorder=document.createElement('div');
  bottomBorder.className='line border h';
  bottomBorder.style.width=(INNER + 2)+'px';
  bottomBorder.style.transform = `translate(${HALF - 1}px, ${(size-1)*CELL+HALF - 1}px)`;
  boardEl.appendChild(bottomBorder);

  const leftBorder=document.createElement('div');
  leftBorder.className='line border v';
  leftBorder.style.height=(INNER + 2)+'px';
  leftBorder.style.transform = `translate(${HALF - 1}px, ${HALF - 1}px)`;
  boardEl.appendChild(leftBorder);

  const rightBorder=document.createElement('div');
  rightBorder.className='line border v';
  rightBorder.style.height=(INNER + 2)+'px';
  rightBorder.style.transform = `translate(${(size-1)*CELL+HALF - 1}px, ${HALF - 1}px)`;
  boardEl.appendChild(rightBorder);

  // Draw a center dot for visual reference, common on physical boards.
  // This is only drawn on odd-sized boards where a true center intersection exists.
  if (size % 2 !== 0) {
    const centerIdx = (size - 1) / 2;
    const centerPos = centerIdx * CELL + HALF;
    const dot = document.createElement('div');
    dot.className = 'center-dot';
    dot.style.left = centerPos + 'px';
    dot.style.top = centerPos + 'px';
    boardEl.appendChild(dot);
  }

  // Coordinate labels (All 4 sides)
  for(let i=0;i<size;i++){
    // Top (A, B, ...)
    const labelTop=document.createElement('div');
    labelTop.className='coordLabel';
    labelTop.style.left=(i*CELL+HALF-4)+'px';
    labelTop.style.top=(HALF-28)+'px';
    labelTop.textContent=String.fromCharCode(65+i);
    boardEl.appendChild(labelTop);

    // Bottom (A, B, ...)
    const labelBottom=document.createElement('div');
    labelBottom.className='coordLabel';
    labelBottom.style.left=(i*CELL+HALF-4)+'px';
    labelBottom.style.top=((size-1)*CELL+HALF+20)+'px';
    labelBottom.textContent=String.fromCharCode(65+i);
    boardEl.appendChild(labelBottom);

    // Left (1, 2, ...)
    const labelLeft=document.createElement('div');
    labelLeft.className='coordLabel';
    labelLeft.style.top=(i*CELL+HALF-6)+'px';
    labelLeft.style.left=(HALF-28)+'px';
    labelLeft.textContent=(i+1);
    boardEl.appendChild(labelLeft);

    // Right (1, 2, ...)
    const labelRight=document.createElement('div');
    labelRight.className='coordLabel';
    labelRight.style.top=(i*CELL+HALF-6)+'px';
    labelRight.style.left=((size-1)*CELL+HALF+20)+'px';
    labelRight.textContent=(i+1);
    boardEl.appendChild(labelRight);
  }

  // Stones (with step numbers)
  for(let r=0;r<size;r++){
    for(let c=0;c<size;c++){
      const val=renderData.board[r][c];
      if(val==='X'||val==='O'){
        const s=document.createElement('div');
        s.className='stone '+val;
        s.style.left=(c*CELL+HALF)+'px';
        s.style.top=(r*CELL+HALF)+'px';
        const idx=renderData.history.findIndex(h=>h.r===r && h.c===c);
        if(idx>=0){
          const tag=document.createElement('span');
          tag.textContent=String(idx+1);
          s.appendChild(tag);
        }
        if (lastMove && r === lastMove.r && c === lastMove.c) {
          s.classList.add('last-move');
        }
        boardEl.appendChild(s);
      }
    }
  }

  // Clickable areas (one per cell)
  for(let r=0;r<size;r++){
    for(let c=0;c<size;c++){
      const area=document.createElement('div');
      area.style.position='absolute';
      area.style.left=(c*CELL)+'px';
      area.style.top=(r*CELL)+'px';
      area.style.width=CELL+'px';
      area.style.height=CELL+'px';
      area.dataset.r=r; area.dataset.c=c;
      area.addEventListener('click',onCellClick);
      boardEl.appendChild(area);
    }
  }
}

function onCellClick(e){
  if(isReplaying || gameOver || overlay.style.display==='flex') return; // Disable moves during replay, game over, or when a popup is shown
  const r=+e.currentTarget.dataset.r;
  const c=+e.currentTarget.dataset.c;
  if(board[r][c]!=='.') return;
  placeStone(r,c,turn);
  if(checkWin(r,c,turn)){
    gameOver = true;
    saveGameBtn.style.display = 'inline-block'; // Show save button
    const L=i18n[langSelect.value];
    overlayText.textContent=(turn==='X'?L.winX:L.winO);
    overlay.style.display='flex';
    return;
  }
  if (history.length === 1) {
    saveGameBtn.style.display = 'inline-block';
  }
  turn=(turn==='X')?'O':'X';
  updateTurn();
}

function placeStone(r,c,who){
  board[r][c]=who;
  history.push({r,c,who});
  renderBoard();
  syncTextFromBoard();
}

function undo(){
  if (isReplaying) return;
  const last=history.pop();
  if(!last) return;
  board[last.r][last.c]='.';
  turn=last.who; // It's the turn of the player who just moved
  gameOver = false; // After undo, the game can continue
  saveGameBtn.style.display = history.length > 0 ? 'inline-block' : 'none';
  hideWinner();
  renderBoard();
  updateTurn();
  syncTextFromBoard();
}

function checkWin(r,c,who){
  const dirs=[[1,0],[0,1],[1,1],[1,-1]];
  for(const [dr,dc] of dirs){
    let count=1;
    for(let k=1;k<5;k++){ const nr=r+dr*k, nc=c+dc*k; if(board[nr]&&board[nr][nc]===who) count++; else break; }
    for(let k=1;k<5;k++){ const nr=r-dr*k, nc=c-dc*k; if(board[nr]&&board[nr][nc]===who) count++; else break; }
    if(count>=5) return true;
  }
  return false;
}

// ======= Text Conversion / File I/O =======
function boardToText(b = board, h = history){
  const boardStr = b.map(row=>row.join('')).join('\n');
  if (h.length === 0) return boardStr;
  const historyStr = h.map(h => `${h.who},${h.r},${h.c}`).join('\n');
  return `${boardStr}\n---\n${historyStr}`;
}

function textToBoard(text){
  const parts = text.split('\n---\n');
  const boardStr = parts[0];
  const historyStr = parts.length > 1 ? parts[1] : '';

  const lines=boardStr.split(/\r?\n/).filter(l=>l.length>0);
  if(lines.length===0) return {n:size, grid:board, newHistory: []};
  const h=lines.length;
  const w=lines.reduce((m,l)=>Math.max(m,l.length),0);
  const n=Math.min(h,w);
  const grid=Array.from({length:n},(_,r)=>Array.from({length:n},(_,c)=>{
    const ch=(lines[r]||'')[c]||'.';
    return (ch==='X'||ch==='O')?ch:'.';
  }));

  const newHistory = historyStr.split(/\r?\n/).filter(l => l.trim()).map(line => {
    const [who, r, c] = line.split(',');
    return { who, r: parseInt(r), c: parseInt(c) };
  }).filter(h => h.who && !isNaN(h.r) && !isNaN(h.c));

  return {n, grid, newHistory};
}

function syncTextFromBoard(b = board, h = history){ txt.value=boardToText(b, h); }

function syncBoardFromText(){
  if (isReplaying) exitReplay();
  const {n, grid, newHistory}=textToBoard(txt.value);
  size=n;
  board=grid;
  history.length = 0;
  Array.prototype.push.apply(history, newHistory);

  if (history.length > 0) {
    const lastMove = history[history.length - 1];
    turn = lastMove.who === 'X' ? 'O' : 'X';
  } else {
    turn = 'X';
  }
  
  gameOver = newHistory.length > 0 && checkWin(newHistory[newHistory.length-1].r, newHistory[newHistory.length-1].c, newHistory[newHistory.length-1].who);
  if(gameOver) saveGameBtn.style.display = 'inline-block'; else saveGameBtn.style.display = 'none';

  document.documentElement.style.setProperty('--size', String(n));
  hideWinner();
  renderBoard();
  updateTurn();
}

function downloadTxt(){
  const now = new Date();
  const year = now.getFullYear();
  const month = String(now.getMonth() + 1).padStart(2, '0');
  const day = String(now.getDate()).padStart(2, '0');
  const hours = String(now.getHours()).padStart(2, '0');
  const minutes = String(now.getMinutes()).padStart(2, '0');
  const seconds = String(now.getSeconds()).padStart(2, '0');
  const timestamp = `${year}${month}${day}_${hours}${minutes}${seconds}`;
  const blob=new Blob([txt.value],{type:'text/plain'});
  const url=URL.createObjectURL(blob);
  const a=document.createElement('a');
  a.href=url; a.download=`gomoku_${size}x${size}_${timestamp}.txt`;
  document.body.appendChild(a); a.click(); document.body.removeChild(a);
  URL.revokeObjectURL(url);
}
function loadFile(file){
  const reader=new FileReader();
  reader.onload=()=>{ txt.value=reader.result; syncBoardFromText(); };
  reader.readAsText(file);
}

function hideWinner(){ overlay.style.display='none'; }

// ======= Game History & Replay (localStorage) =======
function getSavedGames(){
  return JSON.parse(localStorage.getItem('gomokuGames') || '[]');
}

function saveCurrentGame(){
  const games = getSavedGames();
  const gameData = boardToText();
  const date = new Date();
  const L = i18n[langSelect.value] || i18n.EN;
  const winner = gameOver ? turn : 'IN_PROGRESS';
  const totalMoves = history.length;
  games.unshift({
    date: `${date.getFullYear()}-${String(date.getMonth()+1).padStart(2,'0')}-${String(date.getDate()).padStart(2,'0')} ${String(date.getHours()).padStart(2,'0')}:${String(date.getMinutes()).padStart(2,'0')}`,
    boardSize: size,
    winner,
    totalMoves,
    data: gameData
  });
  localStorage.setItem('gomokuGames', JSON.stringify(games));
  renderGameHistory();
  if (gameOver) {
    saveGameBtn.style.display = 'none'; // Hide after saving a finished game
  }
}

function renderGameHistory(){
  const games = getSavedGames();
  const L = i18n[langSelect.value] || i18n.EN;
  gameHistoryListEl.innerHTML = '';
  if (games.length === 0) {
    gameHistoryListEl.innerHTML = `<p>${L.noHistory}</p>`;
    return;
  }
  games.forEach((game, index) => {
    const item = document.createElement('div');
    item.className = 'historyItem';
    
    let statusText;
    switch (game.winner) {
      case 'X': statusText = L.blackWins; break;
      case 'O': statusText = L.whiteWins; break;
      case 'IN_PROGRESS': statusText = L.inProgress; break;
      default: statusText = game.winner; // For backward compatibility
    }

    const info = document.createElement('div');
    info.innerHTML = `
      <strong>${game.date}</strong>
      <br>
      <span>${game.boardSize}x${game.boardSize} / ${game.totalMoves}${L.moves} / ${statusText}</span>
    `;
    
    const deleteBtn = document.createElement('button');
    deleteBtn.className = 'deleteBtn';
    deleteBtn.textContent = L.delete;
    deleteBtn.onclick = (event) => {
      event.stopPropagation(); // Prevent triggering the replay
      deleteGameHistoryItem(index);
    };
    
    item.appendChild(info);
    item.appendChild(deleteBtn);
    
    item.onclick = (event) => {
      // Ensure the click is not on the delete button itself
      if (event.target !== deleteBtn) {
        startReplay(index);
      }
    };
    
    gameHistoryListEl.appendChild(item);
  });
}

function clearGameHistory(){
  const L = i18n[langSelect.value] || i18n.EN;
  if (confirm(L.clearHistoryConfirm)) {
    localStorage.removeItem('gomokuGames');
    renderGameHistory();
  }
}

function deleteGameHistoryItem(index) {
  const L = i18n[langSelect.value] || i18n.EN;
  if (confirm(L.deleteConfirm)) {
    const games = getSavedGames();
    games.splice(index, 1);
    localStorage.setItem('gomokuGames', JSON.stringify(games));
    renderGameHistory();
  }
}

function startReplay(gameIndex) {
  const games = getSavedGames();
  if (gameIndex < 0 || gameIndex >= games.length) return;
  const gameData = games[gameIndex].data;
  setupReplay(gameData);
}

function setupReplay(gameData) {
  if (isReplaying) exitReplay();

  const { n, grid, newHistory } = textToBoard(gameData);

  const initialBoard = JSON.parse(JSON.stringify(grid)); // Deep copy
  for (const move of newHistory) {
    initialBoard[move.r][move.c] = '.';
  }

  isReplaying = true;
  replayHistory = newHistory;
  replayStep = newHistory.length - 1; // Set step to the end for replay controls
  size = n;
  replayInitialBoard = initialBoard; // Store the initial board
  
  document.documentElement.style.setProperty('--size', String(n));
  
  // Switch UI
  document.getElementById('mainControls').style.display = 'none';
  replayControlsEl.style.display = 'flex';
  
  // Directly render the final board state using the parsed grid and full history
  renderBoard({ board: grid, history: newHistory });
  syncTextFromBoard(grid, newHistory);
  updateTurn();
}

function exitReplay() {
  isReplaying = false;
  replayHistory = [];
  replayStep = -1;

  // Switch UI
  document.getElementById('mainControls').style.display = 'flex';
  replayControlsEl.style.display = 'none';
  
  initBoard(parseInt(sizeInput.value) || 15); // Return to initial state
}

function renderReplayStep() {
  const tempBoard = JSON.parse(JSON.stringify(replayInitialBoard));
  const tempHistory = replayHistory.slice(0, replayStep + 1);
  
  for(const move of tempHistory) {
    tempBoard[move.r][move.c] = move.who;
  }
  
  renderBoard({ board: tempBoard, history: tempHistory });
  syncTextFromBoard(tempBoard, tempHistory);
  updateTurn();
}

function replayStepChange(delta) {
  const newStep = replayStep + delta;
  if (newStep >= -1 && newStep < replayHistory.length) {
    replayStep = newStep;
    renderReplayStep();
  }
}

function replayGoTo(target) {
  if (target === 'start') {
    replayStep = -1;
  } else if (target === 'end') {
    replayStep = replayHistory.length - 1;
  }
  renderReplayStep();
}

// --- Kifu Library ---
const kifuFiles = ['01.txt', '02.txt'];
function populateKifuSelect() {
  const kifuSelect = document.getElementById('kifuSelect');
  kifuFiles.forEach(file => {
    const option = document.createElement('option');
    option.value = file;
    option.textContent = file.replace('.txt', ''); // Show '01', '02'
    kifuSelect.appendChild(option);
  });
}

// ======= Event Listeners =======
newBoardBtn.onclick=()=>{ const n=parseInt(sizeInput.value)||15; initBoard(n); };
undoBtn.onclick=undo;
saveGameBtn.onclick = saveCurrentGame;
clearHistoryBtn.onclick = clearGameHistory;
langSelect.onchange=()=>setLanguage(langSelect.value);
document.getElementById('syncFromBoardBtn').onclick=syncTextFromBoard;
document.getElementById('syncToBoardBtn').onclick=syncBoardFromText;
document.getElementById('downloadBtn').onclick=downloadTxt;
document.getElementById('loadFileBtn').onclick=()=>{ const f=document.getElementById('fileInput').files[0]; if(f) loadFile(f); };
document.getElementById('fileInput').addEventListener('change', () => {
  const fileInput = document.getElementById('fileInput');
  const loadFileBtn = document.getElementById('loadFileBtn');
  loadFileBtn.disabled = fileInput.files.length === 0;
});
document.getElementById('copyBtn').onclick=async()=>{ try{ await navigator.clipboard.writeText(txt.value); } catch(e){ txt.select(); document.execCommand('copy'); } };
closeOverlayBtn.onclick=hideWinner;
window.addEventListener('keydown',e=>{ if(e.key==='Escape') hideWinner(); });

document.getElementById('loadKifuBtn').onclick = () => {
  const kifuSelect = document.getElementById('kifuSelect');
  const selectedFile = kifuSelect.value;
  if (!selectedFile) return;

  fetch(selectedFile)
    .then(response => {
      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      return response.text();
    })
    .then(data => {
      txt.value = data;
      syncBoardFromText();
    })
    .catch(e => {
      console.error('Error loading kifu file:', e);
      alert(`Could not load ${selectedFile}. See console for details.`);
    });
};

// --- Replay Event Listeners ---
document.getElementById('replayStartBtn').onclick = () => replayGoTo('start');
document.getElementById('replayPrevBtn').onclick = () => replayStepChange(-1);
document.getElementById('replayNextBtn').onclick = () => replayStepChange(1);
document.getElementById('replayEndBtn').onclick = () => replayGoTo('end');
document.getElementById('replayExitBtn').onclick = exitReplay;


// ======= Initialization =======
function initializeApp() {
  const savedLang = localStorage.getItem('gomokuLang') || 'EN';
  initBoard(15);
  setLanguage(savedLang);
  populateKifuSelect();
}
initializeApp();

// ======= Service Worker Registration =======
if ('serviceWorker' in navigator) {
  window.addEventListener('load', () => {
    navigator.serviceWorker.register('./sw.js')
      .then(registration => {
        console.log('ServiceWorker registration successful:', registration.scope);
      })
      .catch(err => {
        console.log('ServiceWorker registration failed:', err);
      });
  });
}
</script>
</body>
</html>
